// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {AutomationCompatibleInterface} from "@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol";
import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";

contract Raffle is AutomationCompatibleInterface, VRFConsumerBaseV2Plus {
    /* ERRORS */
    error Raffle__AlreadyEntered();
    error Raffle__NotEnoughFunds();
    /* TYPES */
    enum State {
        Opened,
        Closed
    }

    /* STORAGE */
    /// @dev 0.1%
    uint256 private constant OWNER_FEE = 1000;

    uint256 private immutable i_minEntryFee;

    uint8 private s_participantsCount;
    uint256 private s_valueToPayToWinner;
    uint256 private s_feesCollected;
    address private s_lastWinner;
    address[] private s_participants;
    mapping(address participant => bool entered) private s_participantsEntered;

    /* EVENTS */
    event ParticipantEntered(address indexed participant, uint256 amount);
    event FeeCollected(uint256 amount);

    /* MODIFIERS */
    /* CONSTRUCTOR */
    constructor(
        address vrfCoordinator,
        uint8 participantsCount,
        uint256 minEntryFee
    ) VRFConsumerBaseV2Plus(vrfCoordinator) {
        s_participantsCount = participantsCount;
        i_minEntryFee = minEntryFee;
    }

    /* EXTERNAL FUNCTIONS */

    function setMinParticipantsCount(
        uint8 participantsCount
    ) external onlyOwner {
        s_participantsCount = participantsCount;
    }

    function enterRaffle() external payable {
        address entrant = msg.sender;
        uint256 amount = msg.value;

        require(!s_participantsEntered[entrant], Raffle__AlreadyEntered());
        require(amount >= i_minEntryFee, Raffle__NotEnoughFunds());

        s_participants.push(entrant);
        s_participantsEntered[entrant] = true;
        uint256 feeCollected = _collectFee(amount);
        s_valueToPayToWinner += amount - feeCollected;
        emit ParticipantEntered(entrant, amount);
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = s_participants.length >= s_participantsCount;
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        // if ((block.timestamp - lastTimeStamp) > interval) {
        //     lastTimeStamp = block.timestamp;
        //     counter = counter + 1;
        // }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    function getLastWinner() external view returns (address) {
        return s_lastWinner;
    }

    /* PUBLIC FUNCTIONS */
    /* INTERNAL FUNCTIONS */

    function fulfillRandomWords(
        uint256 requestId,
        uint256[] calldata randomWords
    ) internal override {}

    /* PRIVATE FUNCTIONS */
    function _collectFee(uint256 amount) private returns (uint256 fee) {
        fee = amount / OWNER_FEE;
        s_feesCollected += fee;
        emit FeeCollected(fee);
    }
}
